"""
Azure Cosmos DB (MongoDB API) cache layer for storing and retrieving question-answer pairs.
"""
import os
import hashlib
from datetime import datetime
from pymongo import MongoClient, ASCENDING
from dotenv import load_dotenv

load_dotenv()

class AnswerCache:
    """
    Manages caching of question-answer pairs in Azure Cosmos DB (MongoDB API).
    This cache prevents repetitive SLM calls for identical questions by storing previous answers.
    """
    
    def __init__(self):
        """
        Initialize the MongoDB client.
        Establishes connection to Azure Cosmos DB and sets up the collection.
        """
        connection_string = os.getenv("AZURE_COSMOS_CONNECTION_STRING")
        
        if not connection_string:
            print("⚠️ Azure Cosmos DB connection string not found. Caching disabled.")
            self.client = None
            self.collection = None
            return
        
        try:
            self.client = MongoClient(connection_string)
            db = self.client["kmu_meet_ki"]
            self.collection = db["answer_cache"]
            
            # Test connection with a ping
            self.client.admin.command('ping')
            
            print("✅ Azure Cosmos DB (MongoDB) connected successfully")
        except Exception as e:
            print(f"❌ Failed to connect to Cosmos DB: {e}")
            self.client = None
            self.collection = None
    
    def _hash_question(self, question: str, department: str) -> str:
        """
        Generates a deterministic SHA-256 hash for a question/department pair.
        This hash acts as the unique index key for looking up cached results.
        
        Args:
            question (str): The user's question.
            department (str): The context (e.g. "Marketing").
            
        Returns:
            str: Hexadecimal hash string.
        """
        combined = f"{department}:{question.lower().strip()}"
        return hashlib.sha256(combined.encode()).hexdigest()
    
    def get_cached_answer(self, question: str, department: str) -> dict:
        """
        Attempts to retrieve a cached answer for a given question.
        
        Args:
            question (str): The user's question.
            department (str): The department context.
            
        Returns:
            dict: The cached document including 'answer', or None if not found.
        """
        if self.collection is None:
            return None
        
        try:
            question_hash = self._hash_question(question, department)
            
            # Query for the cached item
            item = self.collection.find_one({
                "question_hash": question_hash,
                "department": department
            })
            
            if item:
                print(f"✅ Cache HIT for: {question[:50]}...")
                return {
                    'answer': item.get('answer'),
                    'cached': True,
                    'created_at': item.get('created_at')
                }
            else:
                print(f"❌ Cache MISS for: {question[:50]}...")
                return None
        except Exception as e:
            print(f"⚠️ Cache lookup error: {e}")
            return None
    
    def store_answer(self, question: str, department: str, answer: str) -> bool:
        """
        Stores a new question-answer pair in the cache.
        Uses 'upsert' logic to update if the entry already exists.
        
        Args:
            question (str): The user's question.
            department (str): The department context.
            answer (str): The answer generated by the SLM.
            
        Returns:
            bool: True if successful, False otherwise.
        """
        if self.collection is None:
            return False
        
        try:
            question_hash = self._hash_question(question, department)
            
            document = {
                'question_hash': question_hash,
                'department': department,
                'question': question,
                'answer': answer,
                'created_at': datetime.utcnow(),
                'validated': True
            }
            
            # Upsert: update if exists, insert if new
            self.collection.update_one(
                {"question_hash": question_hash, "department": department},
                {"$set": document},
                upsert=True
            )
            
            print(f"✅ Cached answer for: {question[:50]}...")
            return True
        except Exception as e:
            print(f"⚠️ Failed to cache answer: {e}")
            return False

# Global cache instance
cache = AnswerCache()


class ValidatedResultsManager:
    """
    Manages the lifecycle of AI tool research results:
    1. Pending: Found by scraper/LLM, waiting for admin review.
    2. Approved: Reviewed by admin, ready for end-users.
    3. Rejected: Discarded results.
    """
    
    def __init__(self):
        """Initialize MongoDB client for the validated_results collection."""
        connection_string = os.getenv("AZURE_COSMOS_CONNECTION_STRING")
        
        if not connection_string:
            print("⚠️ Azure Cosmos DB connection string not found. Validated results disabled.")
            self.client = None
            self.collection = None
            return
        
        try:
            self.client = MongoClient(connection_string)
            db = self.client["kmu_meet_ki"]
            self.collection = db["validated_results"]
            print("✅ ValidatedResultsManager connected to Cosmos DB")
        except Exception as e:
            print(f"❌ Failed to connect ValidatedResultsManager: {e}")
            self.client = None
            self.collection = None
    
    def add_pending_result(self, query: str, department: str, llm_analysis: str, apertus_validation: str, tool_name: str = None, source_url: str = None) -> str:
        """
        Add a new research result with 'pending' status.
        
        Args:
            query (str): The search query used.
            department (str): The department context.
            llm_analysis (str): Description or analysis from the LLM.
            apertus_validation (str): Metadata about validation source.
            tool_name (str): The extracted tool name.
            source_url (str, optional): URL source.
            
        Returns:
            str: The unique result_id generated.
        """
        if self.collection is None:
            return None
        
        try:
            # Generate a consistent ID
            result_id = hashlib.sha256(f"{query}:{department}:{datetime.utcnow().isoformat()}".encode()).hexdigest()[:16]
            
            document = {
                'result_id': result_id,
                'query': query,
                'tool_name': tool_name or query[:50],  # Use tool_name if provided, else query
                'source_url': source_url or '',
                'department': department,
                'llm_analysis': llm_analysis,
                'apertus_validation': apertus_validation,
                'status': 'pending',
                'approved_by': None,
                'created_at': datetime.utcnow(),
                'approved_at': None
            }
            
            self.collection.insert_one(document)
            print(f"✅ Added pending result: {result_id} - {tool_name}")
            return result_id
        except Exception as e:
            print(f"⚠️ Failed to add pending result: {e}")
            return None
    
    def get_pending_results(self) -> list:
        """Get all results with 'pending' status (for Admin Dashboard)."""
        if self.collection is None:
            return []
        
        try:
            results = list(self.collection.find({'status': 'pending'}))
            return results
        except Exception as e:
            print(f"⚠️ Failed to get pending results: {e}")
            return []
    
    def get_approved_by_department(self, department: str) -> list:
        """Get all approved results for a specific department (for SLM Service)."""
        if self.collection is None:
            return []
        
        try:
            results = list(self.collection.find({
                'status': 'approved',
                'department': department
            }))
            return results
        except Exception as e:
            print(f"⚠️ Failed to get approved results: {e}")
            return []
    
    def get_all_approved(self) -> list:
        """Get all approved results across all departments."""
        if self.collection is None:
            return []
        
        try:
            results = list(self.collection.find({'status': 'approved'}))
            return results
        except Exception as e:
            print(f"⚠️ Failed to get all approved results: {e}")
            return []
    
    def approve_result(self, result_id: str, approved_by: str) -> bool:
        """
        Transfers a result from 'pending' to 'approved'.
        
        Args:
            result_id (str): The ID of the item to approve.
            approved_by (str): The username/email of the approver.
        """
        if self.collection is None:
            return False
        
        try:
            result = self.collection.update_one(
                {'result_id': result_id, 'status': 'pending'},
                {'$set': {
                    'status': 'approved',
                    'approved_by': approved_by,
                    'approved_at': datetime.utcnow()
                }}
            )
            if result.modified_count > 0:
                print(f"✅ Approved result: {result_id}")
                return True
            return False
        except Exception as e:
            print(f"⚠️ Failed to approve result: {e}")
            return False
    
    def reject_result(self, result_id: str) -> bool:
        """Mark a pending result as 'rejected'."""
        if self.collection is None:
            return False
        
        try:
            result = self.collection.update_one(
                {'result_id': result_id, 'status': 'pending'},
                {'$set': {'status': 'rejected'}}
            )
            if result.modified_count > 0:
                print(f"❌ Rejected result: {result_id}")
                return True
            return False
        except Exception as e:
            print(f"⚠️ Failed to reject result: {e}")
            return False
    
    def revoke_approval(self, result_id: str) -> bool:
        """Moves an item back from 'approved' to 'pending'."""
        if self.collection is None:
            return False
        
        try:
            result = self.collection.update_one(
                {'result_id': result_id, 'status': 'approved'},
                {'$set': {
                    'status': 'pending',
                    'approved_by': None,
                    'approved_at': None
                }}
            )
            return result.modified_count > 0
        except Exception as e:
            print(f"⚠️ Failed to revoke approval: {e}")
            return False


# Global validated results manager instance
validated_results_manager = ValidatedResultsManager()
